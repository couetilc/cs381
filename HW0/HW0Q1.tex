\documentclass[letterpaper,11pt]{article}
\usepackage[utf8]{inputenc}

\usepackage[margin=1in]{geometry} %One inch margins

%Makes things a little prettier
\usepackage{lmodern}%
\usepackage[T1]{fontenc}%
\usepackage{microtype}%
\usepackage[varqu,varl]{inconsolata} % sans serif typewriter

% Bring in the math!
\usepackage{amsmath}%
\usepackage{amsthm}%
\usepackage{amssymb}%
\usepackage{amsfonts}%

% mleftright is helpful for making the parenthesis (and other delimiters) fit their contents height-wise.
\usepackage{mleftright}%
% The following macro puts parenthesis around the contents using mleftright and adapt the height.
\newcommand{\parof}[1]{\mleft( #1 \mright)}
% Of course you can define similar commands for other delimiters.



% To typeset algorithms I simply use numbered lists (e.g., enumerate). I use nested lists for inner clauses. The following is a prettier version of this approach that I use in my notes; it changes the font of the numbering to typewriter font (as a visual cue), normalizes some margins, and so forth. I often put the whole algorithm inside a \begin{quote}...\end{quote} to help set it apart from the text. You can use labels and references (as usual) to refer to steps.

\usepackage{enumitem}%

\newcommand{\stepsfont}{\normalfont}%

\usepackage{enumitem}
\newlist{steps}{enumerate}{9}
\setlist[steps]{before=\upshape\stepsfont,font=\ttfamily} %
\setlist[steps,1]{leftmargin=*,labelsep=1ex,label={\arabic*.},ref={\arabic*}} %
\setlist[steps,2]{leftmargin=*,labelsep=1ex,label={\Alph*.},ref={\thestepsi.\Alph*}} %
\setlist[steps,3]{leftmargin=*,labelsep=1ex,label={\arabic*.},
  ref={\thestepsii.\arabic*}} %
\setlist[steps,4]{leftmargin=*,labelsep=1ex,label={\alph*.},
  ref={\thestepsiii.\alph*}} %
\setlist[steps,5]{leftmargin=*,labelsep=1ex,label={\arabic*.},
  ref={\thestepsiv.\arabic*}} %
\setlist[steps,6]{leftmargin=*,labelsep=1ex,label={\Alph*.},
  ref={\thestepsv.\Alph*}} %
\setlist[steps,7]{leftmargin=*,labelsep=1ex,label=\arabic*.,
  ref={\thestepsvi.\roman*}} %
\setlist[steps,8]{leftmargin=*,labelsep=1ex,label={\alph*.},
  ref={\thestepsvii.\alph*}} %
\setlist[steps,9]{leftmargin=*,labelsep=1ex,label={\arabic*.},
  ref={\thestepsviii.\arabic*}} %
\newlist{stepitems}{itemize}{1} % For when I want to put an itemized list inside the code.
\setlist[stepitems]{before=\upshape\ttfamily,label=*,leftmargin=*,labelsep=1ex}%



\title{CS381 Homework 0 Problem 1}
\author{Connor Couetil}
\date{\today}

\begin{document}

\maketitle

\section{Exercise 1.3.1}

You can tell where you are in a rotated array by comparing against the first element of the array. That way, you tell if you are in the rotated portion or merely the shifted portion.

\paragraph{Recursive Algorithm}

\begin{quote}
    \noindent\texttt{\underline{RotationIndex($array$, $start$, $end$)}}
    \begin{steps}
        \item If $start == end$
        \begin{steps}
            \item Return $1$
        \end{steps}
        \item $midpoint$ = $\lceil (end - start + 1) / 2 \rceil + start$
        \item $neighbor$ = $(midpoint - 1)$ mod Length($array$)
        \item If $array[midpoint] < array[neighbor]$
        \begin{steps}
            \item Return $midpoint$
        \end{steps}
        \item If $array[midpoint] > array[1]$
        \begin{steps}
            \item Return RotationIndex($array$, $midpoint$, $end$)
        \end{steps}
        \item Return RotationIndex($array$, $start$, $midpoint$)
    \end{steps}
\end{quote}

\paragraph{Runtime Analysis}

O(log $n$) due to recurrence relation $\approx$ $S(n) = S(n/2) + c$, $S(1) = C$

\section{Exercise 1.3.2}

For every point in a binary search, we check the neighbors of the midpoint for a peak, otherwise we follow the upslope to the peak of the mountain.

\paragraph{Recursive Algorithm}

\begin{quote}
    \noindent\texttt{\underline{MountainIndex($array$, $start$, $end$)}}
    \begin{steps}
        \item If $start == end$
        \begin{steps}
            \item Return $1$
        \end{steps}
        \item $midpoint$ = $\lceil (end - start + 1) / 2 \rceil + start$
        \item $left$ = $(midpoint - 1)$ mod Length($array$)
        \item $right$ = $(midpoint - 1)$ mod Length($array$)
        \item If $array[midpoint] > array[left]$ and  $array[midpoint] > array[right]$
        \begin{steps}
            \item Return $midpoint$
        \end{steps}
        \item If $array[midpoint] > array[left]$
        \begin{steps}
            \item Return MountainIndex($array$, $midpoint$, $end$)
        \end{steps}
        \item Return MountainIndex($array$, $start$, $midpoint$)
    \end{steps}
\end{quote}

\paragraph{Runtime Analysis}

O(log $n$) due to recurrence relation $\approx$ $S(n) = S(n/2) + c$, $S(1) = C$

\section{Exercise 1.3.3}

\paragraph{Recursive Algorithm}

The heuristic is to follow a downslope or unslope until the local minimum. If we
follow the slope, we either meet a boundary condition, or we must meet a point
at which the slope turns.

Assuming the array has a non-zero length.

\begin{quote}
    \noindent\texttt{\underline{LocalMinimum($array$, $start$, $length$)}}
    \begin{steps}
        \item If $length$ == 1
        \begin{steps}
            \item Return $start$
        \end{steps}
        \item If $array[start]$ < $array[start + 1]$
        \begin{steps}
            \item Return $start$
        \end{steps}
        \item If $array[start + length - 1]$ < $array[start + length - 2]$
        \begin{steps}
            \item Return $start + length - 1$
        \end{steps}
        \item return Search($array$, $start$, $length$) \texttt{// into recursion}
    \end{steps}
    \noindent\texttt{\underline{Search($array$, $start$, $length$)}}
    \begin{steps}
        \item $midpoint = start + length / 2$
        \item $array[midpoint] < array[midpoint - 1]$ and $array[midpoint] < array[midpoint + 1]$
        \begin{steps}
            \item Return $midpoint$
        \end{steps}
        \item If $array[midpoint] > array[midpoint + 1]$ \texttt{// downslopes to right}
        \begin{steps}
            \item Return Search($array$, $midpoint$, $length / 2$)
        \end{steps}
        \item Return Search($array$, $start$, $length / 2$) \texttt{// upslopes to right}
    \end{steps}
\end{quote}

\paragraph{Runtime Analysis}

O(log $n$) due to recurrence relation $\approx$ $S(n) = S(n/2) + c$, $S(1) = C$

\section{Exercise 1.3.4}

\end{document}