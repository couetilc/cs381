\documentclass[letterpaper,11pt]{article}
\usepackage[utf8]{inputenc}

\usepackage[margin=1in]{geometry} %One inch margins

%Makes things a little prettier
\usepackage{lmodern}%
\usepackage[T1]{fontenc}%
\usepackage{microtype}%
\usepackage[varqu,varl]{inconsolata} % sans serif typewriter

% Bring in the math!
\usepackage{amsmath}%
\usepackage{amsthm}%
\usepackage{amssymb}%
\usepackage{amsfonts}%

% mleftright is helpful for making the parenthesis (and other delimiters) fit their contents height-wise.
\usepackage{mleftright}%
% The following macro puts parenthesis around the contents using mleftright and adapt the height.
\newcommand{\parof}[1]{\mleft( #1 \mright)}
% Of course you can define similar commands for other delimiters.



% To typeset algorithms I simply use numbered lists (e.g., enumerate). I use nested lists for inner clauses. The following is a prettier version of this approach that I use in my notes; it changes the font of the numbering to typewriter font (as a visual cue), normalizes some margins, and so forth. I often put the whole algorithm inside a \begin{quote}...\end{quote} to help set it apart from the text. You can use labels and references (as usual) to refer to steps.

\usepackage{enumitem}%

\newcommand{\stepsfont}{\normalfont}%

\usepackage{enumitem}
\newlist{steps}{enumerate}{9}
\setlist[steps]{before=\upshape\stepsfont,font=\ttfamily} %
\setlist[steps,1]{leftmargin=*,labelsep=1ex,label={\arabic*.},ref={\arabic*}} %
\setlist[steps,2]{leftmargin=*,labelsep=1ex,label={\Alph*.},ref={\thestepsi.\Alph*}} %
\setlist[steps,3]{leftmargin=*,labelsep=1ex,label={\arabic*.},
  ref={\thestepsii.\arabic*}} %
\setlist[steps,4]{leftmargin=*,labelsep=1ex,label={\alph*.},
  ref={\thestepsiii.\alph*}} %
\setlist[steps,5]{leftmargin=*,labelsep=1ex,label={\arabic*.},
  ref={\thestepsiv.\arabic*}} %
\setlist[steps,6]{leftmargin=*,labelsep=1ex,label={\Alph*.},
  ref={\thestepsv.\Alph*}} %
\setlist[steps,7]{leftmargin=*,labelsep=1ex,label=\arabic*.,
  ref={\thestepsvi.\roman*}} %
\setlist[steps,8]{leftmargin=*,labelsep=1ex,label={\alph*.},
  ref={\thestepsvii.\alph*}} %
\setlist[steps,9]{leftmargin=*,labelsep=1ex,label={\arabic*.},
  ref={\thestepsviii.\arabic*}} %
\newlist{stepitems}{itemize}{1} % For when I want to put an itemized list inside the code.
\setlist[stepitems]{before=\upshape\ttfamily,label=*,leftmargin=*,labelsep=1ex}%



\title{CS381 Homework 0 Problem 1}
\author{Connor Couetil}
\date{\today}

\begin{document}

\maketitle

\section{Exercise 1.3.1}

You can tell where you are in a rotated array by comparing against the first element of the array. That way, you tell if you are in the rotated portion or merely the shifted portion.

\paragraph{Recursive Algorithm}

\begin{quote}
    \noindent\texttt{\underline{RotationIndex($array$, $start$, $end$)}}
    \begin{steps}
        \item If $start == end$
        \begin{steps}
            \item Return $1$
        \end{steps}
        \item $midpoint$ = $\lceil (end - start + 1) / 2 \rceil + start$
        \item $neighbor$ = $(midpoint - 1)$ mod Length($array$)
        \item If $array[midpoint] < array[neighbor]$
        \begin{steps}
            \item Return $midpoint$
        \end{steps}
        \item If $array[midpoint] > array[1]$
        \begin{steps}
            \item Return RotationIndex($array$, $midpoint$, $end$)
        \end{steps}
        \item Return RotationIndex($array$, $start$, $midpoint$)
    \end{steps}
\end{quote}

\paragraph{Runtime Analysis}

O(log $n$) as we are using binary search to move through the array. The recurrence relation $\approx$ $S(n) = S(n/2) + c$, $S(1) = C$, $n$ approaches the base cases logarithmically.

\section{Exercise 1.3.2}

For every point in a binary search, we check the neighbors of the midpoint for a peak, otherwise we follow the upslope to the peak of the mountain.

\paragraph{Recursive Algorithm}

\begin{quote}
    \noindent\texttt{\underline{MountainIndex($array$, $start$, $end$)}}
    \begin{steps}
        \item If $start == end$
        \begin{steps}
            \item Return $1$
        \end{steps}
        \item $midpoint$ = $\lceil (end - start + 1) / 2 \rceil + start$
        \item $left$ = $(midpoint - 1)$ mod Length($array$)
        \item $right$ = $(midpoint - 1)$ mod Length($array$)
        \item If $array[midpoint] > array[left]$ and  $array[midpoint] > array[right]$
        \begin{steps}
            \item Return $midpoint$
        \end{steps}
        \item If $array[midpoint] > array[left]$
        \begin{steps}
            \item Return MountainIndex($array$, $midpoint$, $end$)
        \end{steps}
        \item Return MountainIndex($array$, $start$, $midpoint$)
    \end{steps}
\end{quote}

\paragraph{Runtime Analysis}

O(log $n$) as we are using binary search to move through the array. The recurrence relation $\approx$ $S(n) = S(n/2) + C$, $S(1) = C$, $n$ approaches the base cases logarithmically, it's halved at each step of the recursion.

\section{Exercise 1.3.3}

\paragraph{Recursive Algorithm}

The heuristic is to follow a downslope or unslope until the local minimum. If we
follow the slope, we either meet a boundary condition, or we must meet a point
at which the slope turns.

Assuming the array has a non-zero length.

\begin{quote}
    \noindent\texttt{\underline{LocalMinimum($array$, $start$, $length$)}}
    \begin{steps}
        \item If $length$ == 1
        \begin{steps}
            \item Return $start$
        \end{steps}
        \item If $array[start]$ < $array[start + 1]$
        \begin{steps}
            \item Return $start$
        \end{steps}
        \item If $array[start + length - 1]$ < $array[start + length - 2]$
        \begin{steps}
            \item Return $start + length - 1$
        \end{steps}
        \item return Search($array$, $start$, $length$) \texttt{// into recursion}
    \end{steps}
    \noindent\texttt{\underline{Search($array$, $start$, $length$)}}
    \begin{steps}
        \item $midpoint = start + length / 2$
        \item $array[midpoint] < array[midpoint - 1]$ and $array[midpoint] < array[midpoint + 1]$
        \begin{steps}
            \item Return $midpoint$
        \end{steps}
        \item If $array[midpoint] > array[midpoint + 1]$ \texttt{// downslopes to right}
        \begin{steps}
            \item Return Search($array$, $midpoint$, $length / 2$)
        \end{steps}
        \item Return Search($array$, $start$, $length / 2$) \texttt{// upslopes to right}
    \end{steps}
\end{quote}

\paragraph{Runtime Analysis}

O(log $n$) as we are using binary search to move through the array. The recurrence relation $\approx$ $S(n) = S(n/2) + C$, $S(1) = C$, $n$ approaches the base cases logarithmically, it's halved at each step of the recursion.

\section{Exercise 1.3.4}

When you realize any array can be split and the sub array will exhibit the same odd gap property, the solution becomes a recursive binary search where you follow the odd arrays to the final odd gap.

\paragraph{Recursive Algorithm}

\begin{quote}
    \noindent\texttt{\underline{OddGap($array$, $start$, $length$)}}
    \begin{steps}
        \item If $length == 2$
        \begin{steps}
            \item Return $start$
        \end{steps}
        \item $midpoint = start + length / 2$
        \item $lparity = array[midpoint] - array[start]$
        \item If $lparity$ mod $2 == 1$
        \begin{steps}
            \item Return OddGap($array$, $start$, $length / 2$)
        \end{steps}
        \item Return OddGap($array$, $start + length / 2$, $length / 2$)
    \end{steps}
\end{quote}

\paragraph{Runtime Analysis}

O(log $n$) as we are using binary search to move through the array. The recurrence relation $\approx$ $S(n) = S(n/2) + C$, $S(2) = C$, $n$ approaches the base cases logarithmically, it's halved at each step of the recursion.

\section{Exercise 1.3.5}

Much like the previous problem, any subarrays must have the same property hold. So, we examine candidate jump pairs recursively, following the subarray where the final element is greater than the first, until we settle at the final jump pair.

\paragraph{Recursive Algorithm}

\begin{quote}
    \noindent\texttt{\underline{Jump($array$, $start$, $length$)}}
    \begin{steps}
        \item If $length == 2$
        \begin{steps}
            \item Return $start$
        \end{steps}
        \item $midpoint = start + length / 2$
        \item $jump = array[midpoint] - array[start]$
        \item If $jump > 0$
        \begin{steps}
            \item Return Jump($array$, $start$, $length / 2$)
        \end{steps}
        \item Return Jump($array$, $start + length / 2$, $length / 2$)
    \end{steps}
\end{quote}

\paragraph{Runtime Analysis}

O(log $n$) as we are using binary search to move through the array. The recurrence relation $\approx$ $S(n) = S(n/2) + C$, $S(2) = C$, $n$ approaches the base cases logarithmically, it's halved at each step of the recursion.

\section{Exercise 1.3.6}

A comparison query has 2 possible outcomes. We have $n$ elements sorted, which means the number of possible starting points for a search is $n$. So, we must have at least $2^k$ comparisons for $n$ elements. This is expressed as $2^k \geq n$, which may be represented as $k \geq log(n)$, meaning the smallest value for $k$ is $log(n)$, or that at least $log(n)$ comparisons must be made for $n$ elements, and that $\Omega(log(n))$ is thus the lower bound for search on a sorted list.

\end{document}